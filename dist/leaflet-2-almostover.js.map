{"version":3,"file":"leaflet-2-almostover.js","sources":["../../leaflet-2.0-geometryUtil/dist/leaflet.geometryutil.js","../src/leaflet.almostover.js"],"sourcesContent":["import {\n    LineUtil,\n    Polyline,\n    Util,\n    Polygon,\n    LatLng,\n    Point,\n    CRS,\n    LayerGroup,\n    Circle\n} from 'leaflet';\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name GeometryUtil\n */\n\n// Internal helper function, formerly L.Polyline._flat\nfunction isFlat (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n}\n\n/**\n * Shortcut function for planar distance between two {LatLng} at current zoom.\n *\n * @tutorial distance-length\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlngA geographical point A\n * @param {LatLng} latlngB geographical point B\n * @returns {Number} planar distance\n */\nexport function distance (map, latlngA, latlngB) {\n    return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n}\n\n/**\n * Shortcut function for planar distance between a {LatLng} and a segment (A-B).\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @returns {Number} planar distance\n */\nexport function distanceSegment (map, latlng, latlngA, latlngB) {\n    const p = map.latLngToLayerPoint(latlng),\n        p1 = map.latLngToLayerPoint(latlngA),\n        p2 = map.latLngToLayerPoint(latlngB);\n    return LineUtil.pointToSegmentDistance(p, p1, p2);\n}\n\n/**\n * Shortcut function for converting distance to readable distance.\n * @param {Number} distance distance to be converted\n * @param {String} unit 'metric' or 'imperial'\n * @returns {String} in yard or miles\n */\nexport function readableDistance (distance, unit) {\n    const isMetric = (unit !== 'imperial');\n    let distanceStr;\n    if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n            distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n            distanceStr = distance.toFixed(1) + ' m';\n        }\n    } else {\n        distance *= 1.09361;\n        if (distance > 1760) {\n            distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n            distanceStr = distance.toFixed(1) + ' yd';\n        }\n    }\n    return distanceStr;\n}\n\n/**\n * Returns true if the latlng belongs to segment A-B\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n * @returns {boolean}\n */\nexport function belongsSegment (latlng, latlngA, latlngB, tolerance = 0.2) {\n    const hypotenuse = latlngA.distanceTo(latlngB);\n    const delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n    return delta / hypotenuse < tolerance;\n}\n\n/**\n * Returns a list of accumulated length along a line.\n * @param {Polyline|Array<Point>|Array<LatLng>} coords Set of coordinates\n * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n */\nexport function accumulatedLengths (coords) {\n    if (typeof coords.getLatLngs == 'function') {\n        coords = coords.getLatLngs();\n    }\n    if (coords.length === 0)\n        return [];\n    let total = 0;\n    const lengths = [0];\n    for (let i = 0, n = coords.length - 1; i < n; i++) {\n        total += (new LatLng(coords[i])).distanceTo(coords[i + 1]);\n        lengths.push(total);\n    }\n    return lengths;\n}\n\n/**\n * Returns total length of line\n * @tutorial distance-length\n *\n * @param {Polyline|Array<Point>|Array<LatLng>} coords Set of coordinates\n * @returns {Number} Total length (pixels for Point, meters for LatLng)\n */\nexport function length (coords) {\n    const accumulated = accumulatedLengths(coords);\n    return accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\n}\n\n/**\n * Returns the closest point of a {LatLng} on the segment (A-B)\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @returns {LatLng} Closest geographical point\n */\nexport function closestOnSegment (map, latlng, latlngA, latlngB) {\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const p = map.project(latlng, maxzoom),\n        p1 = map.project(latlngA, maxzoom),\n        p2 = map.project(latlngB, maxzoom),\n        closest = LineUtil.closestPointOnSegment(p, p1, p2);\n    return map.unproject(closest, maxzoom);\n}\n\n/**\n * Returns the closest point of a {LatLng} on a {Circle}\n *\n * @tutorial closest\n *\n * @param {Circle} circle - A Circle defined by a center and a radius\n * @param {LatLng} latLng - The position to search\n * @returns {LatLng} Closest geographical point on the circle circumference\n */\nexport function closestOnCircle (circle, latLng) {\n    const center = circle.getLatLng();\n    const circleRadius = circle.getRadius();\n    const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n    const x = latLng.lng;\n    const y = latLng.lat;\n    const cx = center.lng;\n    const cy = center.lat;\n    // dx and dy is the vector from the circle's center to latLng\n    const dx = x - cx;\n    const dy = y - cy;\n\n    // distance between the point and the circle's center\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Calculate the closest point on the circle by adding the normalized vector to the center\n    const tx = cx + (dx / distance) * radius;\n    const ty = cy + (dy / distance) * radius;\n\n    return new LatLng(ty, tx);\n}\n\n\n/**\n * Returns the closest latlng on layer.\n *\n * Accept nested arrays\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<LatLng>|Array<Array<LatLng>>|Polyline|Polygon} layer - Layer that contains the result\n * @param {LatLng} latlng - The position to search\n * @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n * @returns {Object} An object with `latlng` and `distance` properties, or `null`.\n */\nexport function closest (map, layer, latlng, vertices) {\n    let latlngs,\n        mindist = Infinity,\n        result = null,\n        i, n, distance, subResult;\n\n    if (layer instanceof Array) {\n        if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n            for (i = 0; i < layer.length; i++) {\n                subResult = closest(map, layer[i], latlng, vertices);\n                if (subResult && subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n        } else if (layer[0] instanceof LatLng ||\n            typeof layer[0][0] === 'number' ||\n            typeof layer[0].lat === 'number') {\n            layer = new Polyline(layer);\n        } else {\n            return result;\n        }\n    }\n\n    if (!(layer instanceof Polyline))\n        return result;\n\n    latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n    if (layer instanceof Polygon) {\n        const addLastSegment = function (latlngsArr) {\n            if (isFlat(latlngsArr)) {\n                latlngsArr.push(latlngsArr[0]);\n            } else {\n                for (let i = 0; i < latlngsArr.length; i++) {\n                    addLastSegment(latlngsArr[i]);\n                }\n            }\n        };\n        addLastSegment(latlngs);\n    }\n\n    if (!isFlat(latlngs)) {\n        for (i = 0; i < latlngs.length; i++) {\n            subResult = closest(map, latlngs[i], latlng, vertices);\n            if (subResult.distance < mindist) {\n                mindist = subResult.distance;\n                result = subResult;\n            }\n        }\n        return result;\n    } else {\n        if (vertices) {\n            for (i = 0, n = latlngs.length; i < n; i++) {\n                const ll = new LatLng(latlngs[i]);\n                distance = this.distance(map, latlng, ll);\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = ll;\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n        for (i = 0, n = latlngs.length; i < n - 1; i++) {\n            const latlngA = new LatLng(latlngs[i]);\n            const latlngB = new LatLng(latlngs[i + 1]);\n            distance = distanceSegment(map, latlng, latlngA, latlngB);\n            if (distance <= mindist) {\n                mindist = distance;\n                result = closestOnSegment(map, latlng, latlngA, latlngB);\n                result.distance = distance;\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * Returns the closest layer to latlng among a list of layers.\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<L.ILayer>} layers Set of layers\n * @param {LatLng} latlng - The position to search\n * @returns {object} `{layer, latlng, distance}` or `null` if list is empty;\n */\nexport function closestLayer (map, layers, latlng) {\n    let mindist = Infinity,\n        result = null,\n        ll = null,\n        distance = Infinity;\n\n    for (let i = 0, n = layers.length; i < n; i++) {\n        const layer = layers[i];\n        if (layer instanceof LayerGroup) {\n            const subResult = closestLayer(map, layer.getLayers(), latlng);\n            if (subResult.distance < mindist) {\n                mindist = subResult.distance;\n                result = subResult;\n            }\n        } else {\n            if (layer instanceof Circle) {\n                ll = closestOnCircle(layer, latlng);\n                distance = this.distance(map, latlng, ll);\n            } else if (typeof layer.getLatLng == 'function') {\n                ll = layer.getLatLng();\n                distance = this.distance(map, latlng, ll);\n            } else {\n                ll = closest(map, layer, latlng);\n                if (ll) distance = ll.distance;\n            }\n            if (distance < mindist) {\n                mindist = distance;\n                result = {\n                    layer: layer,\n                    latlng: ll,\n                    distance: distance\n                };\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the n closest layers to latlng among a list of input layers.\n *\n * @param {L.Map} map - Leaflet map to be used for this method\n * @param {Array<L.ILayer>} layers - Set of layers\n * @param {LatLng} latlng - The position to search\n * @param {?Number} [n=layers.length] - the expected number of output layers.\n * @returns {Array<object>} an array of objects `{layer, latlng, distance}` or `null` if the input is invalid\n */\nexport function nClosestLayers (map, layers, latlng, n) {\n    n = typeof n === 'number' ? n : layers.length;\n\n    if (n < 1 || layers.length < 1) {\n        return null;\n    }\n\n    const results = [];\n    let distance, ll;\n\n    for (let i = 0, m = layers.length; i < m; i++) {\n        const layer = layers[i];\n        if (layer instanceof LayerGroup) {\n            const subResult = closestLayer(map, layer.getLayers(), latlng);\n            results.push(subResult);\n        } else {\n            if (layer instanceof Circle) {\n                ll = closestOnCircle(layer, latlng);\n                distance = this.distance(map, latlng, ll);\n            } else if (typeof layer.getLatLng == 'function') {\n                ll = layer.getLatLng();\n                distance = this.distance(map, latlng, ll);\n            } else {\n                ll = closest(map, layer, latlng);\n                if (ll) distance = ll.distance;\n            }\n            results.push({\n                layer: layer,\n                latlng: ll,\n                distance: distance\n            });\n        }\n    }\n\n    results.sort((a, b) => a.distance - b.distance);\n\n    if (results.length > n) {\n        return results.slice(0, n);\n    } else {\n        return results;\n    }\n}\n\n/**\n * Returns all layers within a radius of the given position, in an ascending order of distance.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<ILayer>} layers - A list of layers.\n * @param {LatLng} latlng - The position to search\n * @param {?Number} [radius=Infinity] - Search radius in pixels\n * @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n */\nexport function layersWithin (map, layers, latlng, radius = Infinity) {\n    const results = [];\n    let ll = null;\n    let distance = 0;\n\n    for (let i = 0, n = layers.length; i < n; i++) {\n        const layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = this.distance(map, latlng, ll);\n        } else {\n            ll = closest(map, layer, latlng);\n            if (ll) distance = ll.distance;\n        }\n\n        if (ll && distance < radius) {\n            results.push({\n                layer: layer,\n                latlng: ll,\n                distance: distance\n            });\n        }\n    }\n\n    return results.sort((a, b) => a.distance - b.distance);\n}\n\n\n/**\n * Returns the closest position from specified {LatLng} among specified layers,\n * with a maximum tolerance in pixels, providing snapping behaviour.\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<ILayer>} layers - A list of layers to snap on.\n * @param {LatLng} latlng - The position to snap\n * @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n * @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n * @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n */\nexport function closestLayerSnap (map, layers, latlng, tolerance = Infinity, withVertices = true) {\n    const result = closestLayer(map, layers, latlng);\n    if (!result || result.distance > tolerance)\n        return null;\n\n    if (withVertices && typeof result.layer.getLatLngs == 'function') {\n        const closestResult = closest(map, result.layer, result.latlng, true);\n        if (closestResult.distance < tolerance) {\n            result.latlng = closestResult;\n            result.distance = this.distance(map, closestResult, latlng);\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the Point located on a segment at the specified ratio of the segment length.\n * @param {Point} pA coordinates of point A\n * @param {Point} pB coordinates of point B\n * @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive.\n * @returns {Point} the interpolated point.\n */\nexport function interpolateOnPointSegment (pA, pB, ratio) {\n    return new Point(\n        (pA.x * (1 - ratio)) + (ratio * pB.x),\n        (pA.y * (1 - ratio)) + (ratio * pB.y)\n    );\n}\n\n/**\n * Returns the coordinate of the point located on a line at the specified ratio of the line length.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<LatLng>|Polyline} latlngs Set of geographical points\n * @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n * @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n */\nexport function interpolateOnLine (map, latLngs, ratio) {\n    latLngs = (latLngs instanceof Polyline) ? latLngs.getLatLngs() : latLngs;\n    const n = latLngs.length;\n    if (n < 2) {\n        return null;\n    }\n\n    ratio = Math.max(Math.min(ratio, 1), 0);\n\n    if (ratio === 0) {\n        return {\n            latLng: latLngs[0] instanceof LatLng ? latLngs[0] : new LatLng(latLngs[0]),\n            predecessor: -1\n        };\n    }\n    if (ratio == 1) {\n        return {\n            latLng: latLngs[n - 1] instanceof LatLng ? latLngs[n - 1] : new LatLng(latLngs[n - 1]),\n            predecessor: n - 2\n        };\n    }\n\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const pts = [];\n    let lineLength = 0;\n    for (let i = 0; i < n; i++) {\n        pts[i] = map.project(latLngs[i], maxzoom);\n        if (i > 0)\n            lineLength += pts[i - 1].distanceTo(pts[i]);\n    }\n\n    const ratioDist = lineLength * ratio;\n    let cumulativeDistanceToB = 0;\n    let pointA, pointB;\n\n    for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n        pointA = pts[i];\n        pointB = pts[i+1];\n        cumulativeDistanceToB += pointA.distanceTo(pointB);\n    }\n\n    if (pointA == undefined && pointB == undefined) { // Happens when line has no length\n        pointA = pts[0];\n        pointB = pts[1];\n        i = 1;\n    }\n\n    const segmentRatio = ((cumulativeDistanceToB - (cumulativeDistanceToB - pointA.distanceTo(pointB))) !== 0) ? ((ratioDist - (cumulativeDistanceToB - pointA.distanceTo(pointB))) / (cumulativeDistanceToB - (cumulativeDistanceToB - pointA.distanceTo(pointB)))) : 0;\n    const interpolatedPoint = interpolateOnPointSegment(pointA, pointB, segmentRatio);\n    return {\n        latLng: map.unproject(interpolatedPoint, maxzoom),\n        predecessor: i - 1\n    };\n}\n\n/**\n * Returns a float between 0 and 1 representing the location of the\n * closest point on polyline to the given latlng, as a fraction of total line length.\n * (opposite of `interpolateOnLine()`)\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Polyline} polyline Polyline on which the latlng will be search\n * @param {LatLng} latlng The position to search\n * @returns {Number} Float between 0 and 1\n */\nexport function locateOnLine (map, polyline, latlng) {\n    const latlngs = polyline.getLatLngs();\n    if (latlng.equals(latlngs[0]))\n        return 0.0;\n    if (latlng.equals(latlngs[latlngs.length - 1]))\n        return 1.0;\n\n    const point = closest(map, polyline, latlng, false);\n    const lengths = accumulatedLengths(latlngs);\n    const totalLength = lengths[lengths.length - 1];\n    let portion = 0;\n    let found = false;\n    for (let i = 0, n = latlngs.length - 1; i < n; i++) {\n        const l1 = new LatLng(latlngs[i]);\n        const l2 = new LatLng(latlngs[i + 1]);\n        portion = lengths[i];\n        if (belongsSegment(point, l1, l2, 0.001)) {\n            portion += l1.distanceTo(point);\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        throw new Error(`Could not interpolate ${latlng.toString()} within polyline.`);\n    }\n    return portion / totalLength;\n}\n\n/**\n * Returns a clone with reversed coordinates.\n * @param {Polyline} polyline polyline to reverse\n * @returns {Polyline} polyline reversed\n */\nexport function reverse (polyline) {\n    return new Polyline(polyline.getLatLngs().slice(0).reverse());\n}\n\n/**\n * Returns a sub-part of the polyline, from start to end.\n * If start is superior to end, returns extraction from inverted line.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Polyline} polyline Polyline on which will be extracted the sub-part\n * @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n * @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n * @returns {Array<LatLng>} new polyline\n */\nexport function extract (map, polyline, start, end) {\n    if (start > end) {\n        return extract(map, reverse(polyline), 1.0 - start, 1.0 - end);\n    }\n\n    start = Math.max(Math.min(start, 1), 0);\n    end = Math.max(Math.min(end, 1), 0);\n\n    const latlngs = polyline.getLatLngs();\n    const startpoint = interpolateOnLine(map, polyline, start);\n    const endpoint = interpolateOnLine(map, polyline, end);\n\n    if (start == end) {\n        const point = interpolateOnLine(map, polyline, end);\n        return [point.latLng];\n    }\n\n    if (startpoint.predecessor == -1)\n        startpoint.predecessor = 0;\n    if (endpoint.predecessor == -1)\n        endpoint.predecessor = 0;\n    const result = latlngs.slice(startpoint.predecessor + 1, endpoint.predecessor + 1);\n    result.unshift(startpoint.latLng);\n    result.push(endpoint.latLng);\n    return result;\n}\n\n/**\n * Returns true if first polyline ends where other second starts.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function isBefore (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    return (new LatLng(lla[lla.length - 1])).equals(new LatLng(llb[0]));\n}\n\n/**\n * Returns true if first polyline starts where second ends.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function isAfter (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    return (new LatLng(lla[0])).equals(new LatLng(llb[llb.length - 1]));\n}\n\n/**\n * Returns true if first polyline starts where second ends or start.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function startsAtExtremity (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    const start = new LatLng(lla[0]);\n    return start.equals(new LatLng(llb[0])) || start.equals(new LatLng(llb[llb.length - 1]));\n}\n\n/**\n * Returns horizontal angle in degrees between two points.\n * @param {Point} a Coordinates of point A\n * @param {Point} b Coordinates of point B\n * @returns {Number} horizontal angle\n */\nexport function computeAngle (a, b) {\n    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n}\n\n/**\n * Returns slope (Ax+B) between two points.\n * @param {Point} a Coordinates of point A\n * @param {Point} b Coordinates of point B\n * @returns {Object} with `a` and `b` properties.\n */\nexport function computeSlope (a, b) {\n    const s = (b.y - a.y) / (b.x - a.x);\n    const o = a.y - (s * a.x);\n    return {\n        'a': s,\n        'b': o\n    };\n}\n\n/**\n * Returns LatLng of rotated point around specified LatLng center.\n * @param {L.Map} map\n * @param {LatLng} latlngPoint: point to rotate\n * @param {double} angleDeg: angle to rotate in degrees\n * @param {LatLng} latlngCenter: center of rotation\n * @returns {LatLng} rotated point\n */\nexport function rotatePoint (map, latlngPoint, angleDeg, latlngCenter) {\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const angleRad = angleDeg * Math.PI / 180;\n    const pPoint = map.project(latlngPoint, maxzoom);\n    const pCenter = map.project(latlngCenter, maxzoom);\n    const x2 = Math.cos(angleRad) * (pPoint.x - pCenter.x) - Math.sin(angleRad) * (pPoint.y - pCenter.y) + pCenter.x;\n    const y2 = Math.sin(angleRad) * (pPoint.x - pCenter.x) + Math.cos(angleRad) * (pPoint.y - pCenter.y) + pCenter.y;\n    return map.unproject(new Point(x2, y2), maxzoom);\n}\n\n/**\n * Returns the bearing in degrees clockwise from north (0 degrees)\n * from the first L.LatLng to the second, at the first LatLng\n * @param {LatLng} latlng1: origin point of the bearing\n * @param {LatLng} latlng2: destination point of the bearing\n * @returns {float} degrees clockwise from north.\n */\nexport function bearing (latlng1, latlng2) {\n    const rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        lon1 = latlng1.lng * rad,\n        lon2 = latlng2.lng * rad,\n        y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n        x = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    const bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n    return bearing >= 180 ? bearing - 360 : bearing;\n}\n\n/**\n * Returns the point that is a distance and heading away from\n * the given origin point.\n * @param {LatLng} latlng: origin point\n * @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n * @param {float} distance: distance in meters\n * @returns {LatLng} the destination point.\n */\nexport function destination (latlng, heading, distance) {\n    heading = (heading + 360) % 360;\n    const rad = Math.PI / 180;\n    const radInv = 180 / Math.PI;\n    const R = CRS.Earth.R; // approximation of Earth's radius\n    const lon1 = latlng.lng * rad;\n    const lat1 = latlng.lat * rad;\n    const rheading = heading * rad;\n    const sinLat1 = Math.sin(lat1);\n    const cosLat1 = Math.cos(lat1);\n    const cosDistR = Math.cos(distance / R);\n    const sinDistR = Math.sin(distance / R);\n    const lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n        sinDistR * Math.cos(rheading));\n    var lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n        cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n    lon2 = lon2 * radInv;\n    const lon2Wrapped = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n    return new LatLng(lat2 * radInv, lon2Wrapped);\n}\n\n/**\n * Returns the the angle of the given segment and the Equator in degrees,\n * clockwise from 0 degrees north.\n * @param {L.Map} map: Leaflet map to be used for this method\n * @param {LatLng} latlngA: geographical point A of the segment\n * @param {LatLng} latlngB: geographical point B of the segment\n * @returns {Float} the angle in degrees.\n */\nexport function angle (map, latlngA, latlngB) {\n    const pointA = map.latLngToContainerPoint(latlngA);\n    const pointB = map.latLngToContainerPoint(latlngB);\n    let angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n    angleDeg += angleDeg < 0 ? 360 : 0;\n    return angleDeg;\n}\n\n/**\n * Returns a point snaps on the segment and heading away from the given origin point a distance.\n * @param {L.Map} map: Leaflet map to be used for this method\n * @param {LatLng} latlngA: geographical point A of the segment\n * @param {LatLng} latlngB: geographical point B of the segment\n * @param {float} distance: distance in meters\n * @returns {LatLng} the destination point.\n */\nexport function destinationOnSegment (map, latlngA, latlngB, distance) {\n    const angleDeg = angle(map, latlngA, latlngB);\n    const latlng = destination(latlngA, angleDeg, distance);\n    return closestOnSegment(map, latlng, latlngA, latlngB);\n}\n","import {Map, Handler, Util} from 'leaflet';\nimport {closestLayerSnap} from 'leaflet-2-geometryutil';\n\n// Extend Leaflet's Map options with AlmostOver options\nMap.mergeOptions({\n    // @option almostOver: Boolean = true\n    // Set it to false to disable this plugin\n    almostOver: true,\n\n    // @option almostDistance: Number = 25\n    // Tolerance in pixels to consider a layer \"almost over\"\n    almostDistance: 25,\n\n    // @option almostSamplingPeriod: Number = 50\n    // Time in ms to throttle mousemove events for performance.\n    almostSamplingPeriod: 50,\n\n    // @option almostOnMouseMove: Boolean = true\n    // Set to false to disable mousemove tracking and only use clicks.\n    almostOnMouseMove: true,\n});\n\n\n/**\n * @class AlmostOverHandler\n * @extends L.Handler\n *\n * This handler fires 'almost:over', 'almost:out', and 'almost:move' events on the map\n * when the mouse is near a layer. It also fires 'almost:click' and 'almost:dblclick'.\n *\n * It requires the Leaflet.GeometryUtil plugin.\n */\nexport class AlmostOverHandler extends Handler {\n\n    initialize (map) {\n        this._map = map;\n        this._layers = [];\n        this._previous = null;\n        this._marker = null;\n        this._buffer = 0;\n\n        // A throttled version of the mousemove handler\n        this._mouseMoveSampler = Util.throttle(this._onMouseMove, this._map.options.almostSamplingPeriod, this);\n    }\n\n    /**\n     * Adds the necessary event listeners to the map.\n     */\n    addHooks () {\n        if (this._map.options.almostOnMouseMove) {\n            this._map.on('mousemove', this._mouseMoveSampler, this);\n        }\n        this._map.on('click dblclick', this._onMouseClick, this);\n\n        // A listener to compute the buffer distance in map units\n        const computeBuffer = () => {\n            if (!this._map) return;\n            const p1 = this._map.layerPointToLatLng([0, 0]);\n            const p2 = this._map.layerPointToLatLng([this._map.options.almostDistance, this._map.options.almostDistance]);\n            this._buffer = p1.distanceTo(p2);\n        };\n\n        this._map.on('viewreset zoomend', computeBuffer, this);\n        this._map.whenReady(computeBuffer, this);\n    }\n\n    /**\n     * Removes the event listeners from the map.\n     */\n    removeHooks () {\n        this._map.off('mousemove', this._mouseMoveSampler, this);\n        this._map.off('click dblclick', this._onMouseClick, this);\n        // Note: 'viewreset' and 'zoomend' listeners for computeBuffer are not removed,\n        // as they are lightweight and handler removal is not always guaranteed.\n    }\n\n    /**\n     * Adds a layer to be considered for \"almost over\" events.\n     * @param {L.Layer} layer\n     */\n    addLayer (layer) {\n        if (typeof layer.eachLayer === 'function') {\n            layer.eachLayer(l => this.addLayer(l), this);\n        } else {\n            // If using a spatial index like LayerIndexMixin, you would index it here.\n            // e.g., if (typeof this.indexLayer === 'function') { this.indexLayer(layer); }\n            this._layers.push(layer);\n        }\n    }\n\n    /**\n     * Removes a layer from \"almost over\" consideration.\n     * @param {L.Layer} layer\n     */\n    removeLayer (layer) {\n        if (typeof layer.eachLayer === 'function') {\n            layer.eachLayer(l => this.removeLayer(l), this);\n        } else {\n            // If using a spatial index, you would unindex it here.\n            // e.g., if (typeof this.unindexLayer === 'function') { this.unindexLayer(layer); }\n            const index = this._layers.indexOf(layer);\n            if (index >= 0) {\n                this._layers.splice(index, 1);\n            }\n        }\n        this._previous = null;\n    }\n\n    /**\n     * Finds the closest layer to a given LatLng.\n     * @param {L.LatLng} latlng\n     * @returns {Object|null} An object with layer, latlng, and distance, or null.\n     */\n    getClosest (latlng) {\n        const distance = this._map.options.almostDistance;\n        let snaplist = this._layers;\n\n        // If using a spatial index, you would search it here for efficiency.\n        // e.g., if (typeof this.searchBuffer === 'function') {\n        //   snaplist = this.searchBuffer(latlng, this._buffer);\n        // }\n\n        return closestLayerSnap(this._map, snaplist, latlng, distance, false);\n    }\n\n    /**\n     * Handles the throttled mousemove event.\n     * @private\n     * @param {L.MouseEvent} e\n     */\n    _onMouseMove (e) {\n        if (!e.latlng) return;\n\n        const closest = this.getClosest(e.latlng);\n\n        if (closest) {\n            if (!this._previous) {\n                // Fire 'over' event if mouse enters a layer's proximity\n                this._map.fire('almost:over', {layer: closest.layer, latlng: closest.latlng});\n            } else if (Util.stamp(this._previous.layer) !== Util.stamp(closest.layer)) {\n                // Fire 'out' and 'over' if mouse moves from one layer's proximity to another\n                this._map.fire('almost:out', {layer: this._previous.layer});\n                this._map.fire('almost:over', {layer: closest.layer, latlng: closest.latlng});\n            }\n\n            // Fire 'move' event while mouse is in proximity\n            this._map.fire('almost:move', {layer: closest.layer, latlng: closest.latlng});\n        } else if (this._previous) {\n                // Fire 'out' event if mouse leaves a layer's proximity\n                this._map.fire('almost:out', {layer: this._previous.layer});\n            }\n        this._previous = closest;\n    }\n\n    /**\n     * Handles click and dblclick events.\n     * @private\n     * @param {L.MouseEvent} e\n     */\n    _onMouseClick (e) {\n        const closest = this.getClosest(e.latlng);\n        if (closest) {\n            this._map.fire(`almost:${e.type}`, {layer: closest.layer, latlng: closest.latlng});\n        }\n    }\n}\n\n// Add the handler to the map's initialization hooks\nMap.addInitHook('addHandler', 'almostOver', AlmostOverHandler);\n"],"names":["Util","LineUtil","LatLng","Polyline","Polygon","LayerGroup","Circle","Map","Handler"],"mappings":"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"}
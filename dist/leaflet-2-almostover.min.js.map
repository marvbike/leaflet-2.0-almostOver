{"version":3,"file":"leaflet-2-almostover.min.js","sources":["../../leaflet-2.0-geometryUtil/dist/leaflet.geometryutil.js","../src/leaflet.almostover.js"],"sourcesContent":["import {\n    LineUtil,\n    Polyline,\n    Util,\n    Polygon,\n    LatLng,\n    Point,\n    CRS,\n    LayerGroup,\n    Circle\n} from 'leaflet';\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name GeometryUtil\n */\n\n// Internal helper function, formerly L.Polyline._flat\nfunction isFlat (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n}\n\n/**\n * Shortcut function for planar distance between two {LatLng} at current zoom.\n *\n * @tutorial distance-length\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlngA geographical point A\n * @param {LatLng} latlngB geographical point B\n * @returns {Number} planar distance\n */\nexport function distance (map, latlngA, latlngB) {\n    return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n}\n\n/**\n * Shortcut function for planar distance between a {LatLng} and a segment (A-B).\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @returns {Number} planar distance\n */\nexport function distanceSegment (map, latlng, latlngA, latlngB) {\n    const p = map.latLngToLayerPoint(latlng),\n        p1 = map.latLngToLayerPoint(latlngA),\n        p2 = map.latLngToLayerPoint(latlngB);\n    return LineUtil.pointToSegmentDistance(p, p1, p2);\n}\n\n/**\n * Shortcut function for converting distance to readable distance.\n * @param {Number} distance distance to be converted\n * @param {String} unit 'metric' or 'imperial'\n * @returns {String} in yard or miles\n */\nexport function readableDistance (distance, unit) {\n    const isMetric = (unit !== 'imperial');\n    let distanceStr;\n    if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n            distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n            distanceStr = distance.toFixed(1) + ' m';\n        }\n    } else {\n        distance *= 1.09361;\n        if (distance > 1760) {\n            distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n            distanceStr = distance.toFixed(1) + ' yd';\n        }\n    }\n    return distanceStr;\n}\n\n/**\n * Returns true if the latlng belongs to segment A-B\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n * @returns {boolean}\n */\nexport function belongsSegment (latlng, latlngA, latlngB, tolerance = 0.2) {\n    const hypotenuse = latlngA.distanceTo(latlngB);\n    const delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n    return delta / hypotenuse < tolerance;\n}\n\n/**\n * Returns a list of accumulated length along a line.\n * @param {Polyline|Array<Point>|Array<LatLng>} coords Set of coordinates\n * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n */\nexport function accumulatedLengths (coords) {\n    if (typeof coords.getLatLngs == 'function') {\n        coords = coords.getLatLngs();\n    }\n    if (coords.length === 0)\n        return [];\n    let total = 0;\n    const lengths = [0];\n    for (let i = 0, n = coords.length - 1; i < n; i++) {\n        total += (new LatLng(coords[i])).distanceTo(coords[i + 1]);\n        lengths.push(total);\n    }\n    return lengths;\n}\n\n/**\n * Returns total length of line\n * @tutorial distance-length\n *\n * @param {Polyline|Array<Point>|Array<LatLng>} coords Set of coordinates\n * @returns {Number} Total length (pixels for Point, meters for LatLng)\n */\nexport function length (coords) {\n    const accumulated = accumulatedLengths(coords);\n    return accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\n}\n\n/**\n * Returns the closest point of a {LatLng} on the segment (A-B)\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {LatLng} latlng - The position to search\n * @param {LatLng} latlngA geographical point A of the segment\n * @param {LatLng} latlngB geographical point B of the segment\n * @returns {LatLng} Closest geographical point\n */\nexport function closestOnSegment (map, latlng, latlngA, latlngB) {\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const p = map.project(latlng, maxzoom),\n        p1 = map.project(latlngA, maxzoom),\n        p2 = map.project(latlngB, maxzoom),\n        closest = LineUtil.closestPointOnSegment(p, p1, p2);\n    return map.unproject(closest, maxzoom);\n}\n\n/**\n * Returns the closest point of a {LatLng} on a {Circle}\n *\n * @tutorial closest\n *\n * @param {Circle} circle - A Circle defined by a center and a radius\n * @param {LatLng} latLng - The position to search\n * @returns {LatLng} Closest geographical point on the circle circumference\n */\nexport function closestOnCircle (circle, latLng) {\n    const center = circle.getLatLng();\n    const circleRadius = circle.getRadius();\n    const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n    const x = latLng.lng;\n    const y = latLng.lat;\n    const cx = center.lng;\n    const cy = center.lat;\n    // dx and dy is the vector from the circle's center to latLng\n    const dx = x - cx;\n    const dy = y - cy;\n\n    // distance between the point and the circle's center\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Calculate the closest point on the circle by adding the normalized vector to the center\n    const tx = cx + (dx / distance) * radius;\n    const ty = cy + (dy / distance) * radius;\n\n    return new LatLng(ty, tx);\n}\n\n\n/**\n * Returns the closest latlng on layer.\n *\n * Accept nested arrays\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<LatLng>|Array<Array<LatLng>>|Polyline|Polygon} layer - Layer that contains the result\n * @param {LatLng} latlng - The position to search\n * @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n * @returns {Object} An object with `latlng` and `distance` properties, or `null`.\n */\nexport function closest (map, layer, latlng, vertices) {\n    let latlngs,\n        mindist = Infinity,\n        result = null,\n        i, n, distance, subResult;\n\n    if (layer instanceof Array) {\n        if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n            for (i = 0; i < layer.length; i++) {\n                subResult = closest(map, layer[i], latlng, vertices);\n                if (subResult && subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n        } else if (layer[0] instanceof LatLng ||\n            typeof layer[0][0] === 'number' ||\n            typeof layer[0].lat === 'number') {\n            layer = new Polyline(layer);\n        } else {\n            return result;\n        }\n    }\n\n    if (!(layer instanceof Polyline))\n        return result;\n\n    latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n    if (layer instanceof Polygon) {\n        const addLastSegment = function (latlngsArr) {\n            if (isFlat(latlngsArr)) {\n                latlngsArr.push(latlngsArr[0]);\n            } else {\n                for (let i = 0; i < latlngsArr.length; i++) {\n                    addLastSegment(latlngsArr[i]);\n                }\n            }\n        };\n        addLastSegment(latlngs);\n    }\n\n    if (!isFlat(latlngs)) {\n        for (i = 0; i < latlngs.length; i++) {\n            subResult = closest(map, latlngs[i], latlng, vertices);\n            if (subResult.distance < mindist) {\n                mindist = subResult.distance;\n                result = subResult;\n            }\n        }\n        return result;\n    } else {\n        if (vertices) {\n            for (i = 0, n = latlngs.length; i < n; i++) {\n                const ll = new LatLng(latlngs[i]);\n                distance = this.distance(map, latlng, ll);\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = ll;\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n        for (i = 0, n = latlngs.length; i < n - 1; i++) {\n            const latlngA = new LatLng(latlngs[i]);\n            const latlngB = new LatLng(latlngs[i + 1]);\n            distance = distanceSegment(map, latlng, latlngA, latlngB);\n            if (distance <= mindist) {\n                mindist = distance;\n                result = closestOnSegment(map, latlng, latlngA, latlngB);\n                result.distance = distance;\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * Returns the closest layer to latlng among a list of layers.\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<L.ILayer>} layers Set of layers\n * @param {LatLng} latlng - The position to search\n * @returns {object} `{layer, latlng, distance}` or `null` if list is empty;\n */\nexport function closestLayer (map, layers, latlng) {\n    let mindist = Infinity,\n        result = null,\n        ll = null,\n        distance = Infinity;\n\n    for (let i = 0, n = layers.length; i < n; i++) {\n        const layer = layers[i];\n        if (layer instanceof LayerGroup) {\n            const subResult = closestLayer(map, layer.getLayers(), latlng);\n            if (subResult.distance < mindist) {\n                mindist = subResult.distance;\n                result = subResult;\n            }\n        } else {\n            if (layer instanceof Circle) {\n                ll = closestOnCircle(layer, latlng);\n                distance = this.distance(map, latlng, ll);\n            } else if (typeof layer.getLatLng == 'function') {\n                ll = layer.getLatLng();\n                distance = this.distance(map, latlng, ll);\n            } else {\n                ll = closest(map, layer, latlng);\n                if (ll) distance = ll.distance;\n            }\n            if (distance < mindist) {\n                mindist = distance;\n                result = {\n                    layer: layer,\n                    latlng: ll,\n                    distance: distance\n                };\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the n closest layers to latlng among a list of input layers.\n *\n * @param {L.Map} map - Leaflet map to be used for this method\n * @param {Array<L.ILayer>} layers - Set of layers\n * @param {LatLng} latlng - The position to search\n * @param {?Number} [n=layers.length] - the expected number of output layers.\n * @returns {Array<object>} an array of objects `{layer, latlng, distance}` or `null` if the input is invalid\n */\nexport function nClosestLayers (map, layers, latlng, n) {\n    n = typeof n === 'number' ? n : layers.length;\n\n    if (n < 1 || layers.length < 1) {\n        return null;\n    }\n\n    const results = [];\n    let distance, ll;\n\n    for (let i = 0, m = layers.length; i < m; i++) {\n        const layer = layers[i];\n        if (layer instanceof LayerGroup) {\n            const subResult = closestLayer(map, layer.getLayers(), latlng);\n            results.push(subResult);\n        } else {\n            if (layer instanceof Circle) {\n                ll = closestOnCircle(layer, latlng);\n                distance = this.distance(map, latlng, ll);\n            } else if (typeof layer.getLatLng == 'function') {\n                ll = layer.getLatLng();\n                distance = this.distance(map, latlng, ll);\n            } else {\n                ll = closest(map, layer, latlng);\n                if (ll) distance = ll.distance;\n            }\n            results.push({\n                layer: layer,\n                latlng: ll,\n                distance: distance\n            });\n        }\n    }\n\n    results.sort((a, b) => a.distance - b.distance);\n\n    if (results.length > n) {\n        return results.slice(0, n);\n    } else {\n        return results;\n    }\n}\n\n/**\n * Returns all layers within a radius of the given position, in an ascending order of distance.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<ILayer>} layers - A list of layers.\n * @param {LatLng} latlng - The position to search\n * @param {?Number} [radius=Infinity] - Search radius in pixels\n * @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n */\nexport function layersWithin (map, layers, latlng, radius = Infinity) {\n    const results = [];\n    let ll = null;\n    let distance = 0;\n\n    for (let i = 0, n = layers.length; i < n; i++) {\n        const layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = this.distance(map, latlng, ll);\n        } else {\n            ll = closest(map, layer, latlng);\n            if (ll) distance = ll.distance;\n        }\n\n        if (ll && distance < radius) {\n            results.push({\n                layer: layer,\n                latlng: ll,\n                distance: distance\n            });\n        }\n    }\n\n    return results.sort((a, b) => a.distance - b.distance);\n}\n\n\n/**\n * Returns the closest position from specified {LatLng} among specified layers,\n * with a maximum tolerance in pixels, providing snapping behaviour.\n *\n * @tutorial closest\n *\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<ILayer>} layers - A list of layers to snap on.\n * @param {LatLng} latlng - The position to snap\n * @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n * @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n * @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n */\nexport function closestLayerSnap (map, layers, latlng, tolerance = Infinity, withVertices = true) {\n    const result = closestLayer(map, layers, latlng);\n    if (!result || result.distance > tolerance)\n        return null;\n\n    if (withVertices && typeof result.layer.getLatLngs == 'function') {\n        const closestResult = closest(map, result.layer, result.latlng, true);\n        if (closestResult.distance < tolerance) {\n            result.latlng = closestResult;\n            result.distance = this.distance(map, closestResult, latlng);\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the Point located on a segment at the specified ratio of the segment length.\n * @param {Point} pA coordinates of point A\n * @param {Point} pB coordinates of point B\n * @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive.\n * @returns {Point} the interpolated point.\n */\nexport function interpolateOnPointSegment (pA, pB, ratio) {\n    return new Point(\n        (pA.x * (1 - ratio)) + (ratio * pB.x),\n        (pA.y * (1 - ratio)) + (ratio * pB.y)\n    );\n}\n\n/**\n * Returns the coordinate of the point located on a line at the specified ratio of the line length.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Array<LatLng>|Polyline} latlngs Set of geographical points\n * @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n * @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n */\nexport function interpolateOnLine (map, latLngs, ratio) {\n    latLngs = (latLngs instanceof Polyline) ? latLngs.getLatLngs() : latLngs;\n    const n = latLngs.length;\n    if (n < 2) {\n        return null;\n    }\n\n    ratio = Math.max(Math.min(ratio, 1), 0);\n\n    if (ratio === 0) {\n        return {\n            latLng: latLngs[0] instanceof LatLng ? latLngs[0] : new LatLng(latLngs[0]),\n            predecessor: -1\n        };\n    }\n    if (ratio == 1) {\n        return {\n            latLng: latLngs[n - 1] instanceof LatLng ? latLngs[n - 1] : new LatLng(latLngs[n - 1]),\n            predecessor: n - 2\n        };\n    }\n\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const pts = [];\n    let lineLength = 0;\n    for (let i = 0; i < n; i++) {\n        pts[i] = map.project(latLngs[i], maxzoom);\n        if (i > 0)\n            lineLength += pts[i - 1].distanceTo(pts[i]);\n    }\n\n    const ratioDist = lineLength * ratio;\n    let cumulativeDistanceToB = 0;\n    let pointA, pointB;\n\n    for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n        pointA = pts[i];\n        pointB = pts[i+1];\n        cumulativeDistanceToB += pointA.distanceTo(pointB);\n    }\n\n    if (pointA == undefined && pointB == undefined) { // Happens when line has no length\n        pointA = pts[0];\n        pointB = pts[1];\n        i = 1;\n    }\n\n    const segmentRatio = ((cumulativeDistanceToB - (cumulativeDistanceToB - pointA.distanceTo(pointB))) !== 0) ? ((ratioDist - (cumulativeDistanceToB - pointA.distanceTo(pointB))) / (cumulativeDistanceToB - (cumulativeDistanceToB - pointA.distanceTo(pointB)))) : 0;\n    const interpolatedPoint = interpolateOnPointSegment(pointA, pointB, segmentRatio);\n    return {\n        latLng: map.unproject(interpolatedPoint, maxzoom),\n        predecessor: i - 1\n    };\n}\n\n/**\n * Returns a float between 0 and 1 representing the location of the\n * closest point on polyline to the given latlng, as a fraction of total line length.\n * (opposite of `interpolateOnLine()`)\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Polyline} polyline Polyline on which the latlng will be search\n * @param {LatLng} latlng The position to search\n * @returns {Number} Float between 0 and 1\n */\nexport function locateOnLine (map, polyline, latlng) {\n    const latlngs = polyline.getLatLngs();\n    if (latlng.equals(latlngs[0]))\n        return 0.0;\n    if (latlng.equals(latlngs[latlngs.length - 1]))\n        return 1.0;\n\n    const point = closest(map, polyline, latlng, false);\n    const lengths = accumulatedLengths(latlngs);\n    const totalLength = lengths[lengths.length - 1];\n    let portion = 0;\n    let found = false;\n    for (let i = 0, n = latlngs.length - 1; i < n; i++) {\n        const l1 = new LatLng(latlngs[i]);\n        const l2 = new LatLng(latlngs[i + 1]);\n        portion = lengths[i];\n        if (belongsSegment(point, l1, l2, 0.001)) {\n            portion += l1.distanceTo(point);\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        throw new Error(`Could not interpolate ${latlng.toString()} within polyline.`);\n    }\n    return portion / totalLength;\n}\n\n/**\n * Returns a clone with reversed coordinates.\n * @param {Polyline} polyline polyline to reverse\n * @returns {Polyline} polyline reversed\n */\nexport function reverse (polyline) {\n    return new Polyline(polyline.getLatLngs().slice(0).reverse());\n}\n\n/**\n * Returns a sub-part of the polyline, from start to end.\n * If start is superior to end, returns extraction from inverted line.\n * @param {L.Map} map Leaflet map to be used for this method\n * @param {Polyline} polyline Polyline on which will be extracted the sub-part\n * @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n * @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n * @returns {Array<LatLng>} new polyline\n */\nexport function extract (map, polyline, start, end) {\n    if (start > end) {\n        return extract(map, reverse(polyline), 1.0 - start, 1.0 - end);\n    }\n\n    start = Math.max(Math.min(start, 1), 0);\n    end = Math.max(Math.min(end, 1), 0);\n\n    const latlngs = polyline.getLatLngs();\n    const startpoint = interpolateOnLine(map, polyline, start);\n    const endpoint = interpolateOnLine(map, polyline, end);\n\n    if (start == end) {\n        const point = interpolateOnLine(map, polyline, end);\n        return [point.latLng];\n    }\n\n    if (startpoint.predecessor == -1)\n        startpoint.predecessor = 0;\n    if (endpoint.predecessor == -1)\n        endpoint.predecessor = 0;\n    const result = latlngs.slice(startpoint.predecessor + 1, endpoint.predecessor + 1);\n    result.unshift(startpoint.latLng);\n    result.push(endpoint.latLng);\n    return result;\n}\n\n/**\n * Returns true if first polyline ends where other second starts.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function isBefore (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    return (new LatLng(lla[lla.length - 1])).equals(new LatLng(llb[0]));\n}\n\n/**\n * Returns true if first polyline starts where second ends.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function isAfter (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    return (new LatLng(lla[0])).equals(new LatLng(llb[llb.length - 1]));\n}\n\n/**\n * Returns true if first polyline starts where second ends or start.\n * @param {Polyline} polyline First polyline\n * @param {Polyline} other Second polyline\n * @returns {bool}\n */\nexport function startsAtExtremity (polyline, other) {\n    if (!other) return false;\n    const lla = polyline.getLatLngs();\n    const llb = other.getLatLngs();\n    const start = new LatLng(lla[0]);\n    return start.equals(new LatLng(llb[0])) || start.equals(new LatLng(llb[llb.length - 1]));\n}\n\n/**\n * Returns horizontal angle in degrees between two points.\n * @param {Point} a Coordinates of point A\n * @param {Point} b Coordinates of point B\n * @returns {Number} horizontal angle\n */\nexport function computeAngle (a, b) {\n    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n}\n\n/**\n * Returns slope (Ax+B) between two points.\n * @param {Point} a Coordinates of point A\n * @param {Point} b Coordinates of point B\n * @returns {Object} with `a` and `b` properties.\n */\nexport function computeSlope (a, b) {\n    const s = (b.y - a.y) / (b.x - a.x);\n    const o = a.y - (s * a.x);\n    return {\n        'a': s,\n        'b': o\n    };\n}\n\n/**\n * Returns LatLng of rotated point around specified LatLng center.\n * @param {L.Map} map\n * @param {LatLng} latlngPoint: point to rotate\n * @param {double} angleDeg: angle to rotate in degrees\n * @param {LatLng} latlngCenter: center of rotation\n * @returns {LatLng} rotated point\n */\nexport function rotatePoint (map, latlngPoint, angleDeg, latlngCenter) {\n    let maxzoom = map.getMaxZoom();\n    if (maxzoom === Infinity)\n        maxzoom = map.getZoom();\n    const angleRad = angleDeg * Math.PI / 180;\n    const pPoint = map.project(latlngPoint, maxzoom);\n    const pCenter = map.project(latlngCenter, maxzoom);\n    const x2 = Math.cos(angleRad) * (pPoint.x - pCenter.x) - Math.sin(angleRad) * (pPoint.y - pCenter.y) + pCenter.x;\n    const y2 = Math.sin(angleRad) * (pPoint.x - pCenter.x) + Math.cos(angleRad) * (pPoint.y - pCenter.y) + pCenter.y;\n    return map.unproject(new Point(x2, y2), maxzoom);\n}\n\n/**\n * Returns the bearing in degrees clockwise from north (0 degrees)\n * from the first L.LatLng to the second, at the first LatLng\n * @param {LatLng} latlng1: origin point of the bearing\n * @param {LatLng} latlng2: destination point of the bearing\n * @returns {float} degrees clockwise from north.\n */\nexport function bearing (latlng1, latlng2) {\n    const rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        lon1 = latlng1.lng * rad,\n        lon2 = latlng2.lng * rad,\n        y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n        x = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    const bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n    return bearing >= 180 ? bearing - 360 : bearing;\n}\n\n/**\n * Returns the point that is a distance and heading away from\n * the given origin point.\n * @param {LatLng} latlng: origin point\n * @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n * @param {float} distance: distance in meters\n * @returns {LatLng} the destination point.\n */\nexport function destination (latlng, heading, distance) {\n    heading = (heading + 360) % 360;\n    const rad = Math.PI / 180;\n    const radInv = 180 / Math.PI;\n    const R = CRS.Earth.R; // approximation of Earth's radius\n    const lon1 = latlng.lng * rad;\n    const lat1 = latlng.lat * rad;\n    const rheading = heading * rad;\n    const sinLat1 = Math.sin(lat1);\n    const cosLat1 = Math.cos(lat1);\n    const cosDistR = Math.cos(distance / R);\n    const sinDistR = Math.sin(distance / R);\n    const lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n        sinDistR * Math.cos(rheading));\n    var lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n        cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n    lon2 = lon2 * radInv;\n    const lon2Wrapped = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n    return new LatLng(lat2 * radInv, lon2Wrapped);\n}\n\n/**\n * Returns the the angle of the given segment and the Equator in degrees,\n * clockwise from 0 degrees north.\n * @param {L.Map} map: Leaflet map to be used for this method\n * @param {LatLng} latlngA: geographical point A of the segment\n * @param {LatLng} latlngB: geographical point B of the segment\n * @returns {Float} the angle in degrees.\n */\nexport function angle (map, latlngA, latlngB) {\n    const pointA = map.latLngToContainerPoint(latlngA);\n    const pointB = map.latLngToContainerPoint(latlngB);\n    let angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n    angleDeg += angleDeg < 0 ? 360 : 0;\n    return angleDeg;\n}\n\n/**\n * Returns a point snaps on the segment and heading away from the given origin point a distance.\n * @param {L.Map} map: Leaflet map to be used for this method\n * @param {LatLng} latlngA: geographical point A of the segment\n * @param {LatLng} latlngB: geographical point B of the segment\n * @param {float} distance: distance in meters\n * @returns {LatLng} the destination point.\n */\nexport function destinationOnSegment (map, latlngA, latlngB, distance) {\n    const angleDeg = angle(map, latlngA, latlngB);\n    const latlng = destination(latlngA, angleDeg, distance);\n    return closestOnSegment(map, latlng, latlngA, latlngB);\n}\n","import {Map, Handler, Util} from 'leaflet';\nimport {closestLayerSnap} from 'leaflet-2-geometryutil';\n\n// Extend Leaflet's Map options with AlmostOver options\nMap.mergeOptions({\n    // @option almostOver: Boolean = true\n    // Set it to false to disable this plugin\n    almostOver: true,\n\n    // @option almostDistance: Number = 25\n    // Tolerance in pixels to consider a layer \"almost over\"\n    almostDistance: 25,\n\n    // @option almostSamplingPeriod: Number = 50\n    // Time in ms to throttle mousemove events for performance.\n    almostSamplingPeriod: 50,\n\n    // @option almostOnMouseMove: Boolean = true\n    // Set to false to disable mousemove tracking and only use clicks.\n    almostOnMouseMove: true,\n});\n\n\n/**\n * @class AlmostOverHandler\n * @extends L.Handler\n *\n * This handler fires 'almost:over', 'almost:out', and 'almost:move' events on the map\n * when the mouse is near a layer. It also fires 'almost:click' and 'almost:dblclick'.\n *\n * It requires the Leaflet.GeometryUtil plugin.\n */\nexport class AlmostOverHandler extends Handler {\n\n    initialize (map) {\n        this._map = map;\n        this._layers = [];\n        this._previous = null;\n        this._marker = null;\n        this._buffer = 0;\n\n        // A throttled version of the mousemove handler\n        this._mouseMoveSampler = Util.throttle(this._onMouseMove, this._map.options.almostSamplingPeriod, this);\n    }\n\n    /**\n     * Adds the necessary event listeners to the map.\n     */\n    addHooks () {\n        if (this._map.options.almostOnMouseMove) {\n            this._map.on('mousemove', this._mouseMoveSampler, this);\n        }\n        this._map.on('click dblclick', this._onMouseClick, this);\n\n        // A listener to compute the buffer distance in map units\n        const computeBuffer = () => {\n            if (!this._map) return;\n            const p1 = this._map.layerPointToLatLng([0, 0]);\n            const p2 = this._map.layerPointToLatLng([this._map.options.almostDistance, this._map.options.almostDistance]);\n            this._buffer = p1.distanceTo(p2);\n        };\n\n        this._map.on('viewreset zoomend', computeBuffer, this);\n        this._map.whenReady(computeBuffer, this);\n    }\n\n    /**\n     * Removes the event listeners from the map.\n     */\n    removeHooks () {\n        this._map.off('mousemove', this._mouseMoveSampler, this);\n        this._map.off('click dblclick', this._onMouseClick, this);\n        // Note: 'viewreset' and 'zoomend' listeners for computeBuffer are not removed,\n        // as they are lightweight and handler removal is not always guaranteed.\n    }\n\n    /**\n     * Adds a layer to be considered for \"almost over\" events.\n     * @param {L.Layer} layer\n     */\n    addLayer (layer) {\n        if (typeof layer.eachLayer === 'function') {\n            layer.eachLayer(l => this.addLayer(l), this);\n        } else {\n            // If using a spatial index like LayerIndexMixin, you would index it here.\n            // e.g., if (typeof this.indexLayer === 'function') { this.indexLayer(layer); }\n            this._layers.push(layer);\n        }\n    }\n\n    /**\n     * Removes a layer from \"almost over\" consideration.\n     * @param {L.Layer} layer\n     */\n    removeLayer (layer) {\n        if (typeof layer.eachLayer === 'function') {\n            layer.eachLayer(l => this.removeLayer(l), this);\n        } else {\n            // If using a spatial index, you would unindex it here.\n            // e.g., if (typeof this.unindexLayer === 'function') { this.unindexLayer(layer); }\n            const index = this._layers.indexOf(layer);\n            if (index >= 0) {\n                this._layers.splice(index, 1);\n            }\n        }\n        this._previous = null;\n    }\n\n    /**\n     * Finds the closest layer to a given LatLng.\n     * @param {L.LatLng} latlng\n     * @returns {Object|null} An object with layer, latlng, and distance, or null.\n     */\n    getClosest (latlng) {\n        const distance = this._map.options.almostDistance;\n        let snaplist = this._layers;\n\n        // If using a spatial index, you would search it here for efficiency.\n        // e.g., if (typeof this.searchBuffer === 'function') {\n        //   snaplist = this.searchBuffer(latlng, this._buffer);\n        // }\n\n        return closestLayerSnap(this._map, snaplist, latlng, distance, false);\n    }\n\n    /**\n     * Handles the throttled mousemove event.\n     * @private\n     * @param {L.MouseEvent} e\n     */\n    _onMouseMove (e) {\n        if (!e.latlng) return;\n\n        const closest = this.getClosest(e.latlng);\n\n        if (closest) {\n            if (!this._previous) {\n                // Fire 'over' event if mouse enters a layer's proximity\n                this._map.fire('almost:over', {layer: closest.layer, latlng: closest.latlng});\n            } else if (Util.stamp(this._previous.layer) !== Util.stamp(closest.layer)) {\n                // Fire 'out' and 'over' if mouse moves from one layer's proximity to another\n                this._map.fire('almost:out', {layer: this._previous.layer});\n                this._map.fire('almost:over', {layer: closest.layer, latlng: closest.latlng});\n            }\n\n            // Fire 'move' event while mouse is in proximity\n            this._map.fire('almost:move', {layer: closest.layer, latlng: closest.latlng});\n        } else if (this._previous) {\n                // Fire 'out' event if mouse leaves a layer's proximity\n                this._map.fire('almost:out', {layer: this._previous.layer});\n            }\n        this._previous = closest;\n    }\n\n    /**\n     * Handles click and dblclick events.\n     * @private\n     * @param {L.MouseEvent} e\n     */\n    _onMouseClick (e) {\n        const closest = this.getClosest(e.latlng);\n        if (closest) {\n            this._map.fire(`almost:${e.type}`, {layer: closest.layer, latlng: closest.latlng});\n        }\n    }\n}\n\n// Add the handler to the map's initialization hooks\nMap.addInitHook('addHandler', 'almostOver', AlmostOverHandler);\n"],"names":["isFlat","latlngs","Util","isArray","distanceSegment","map","latlng","latlngA","latlngB","p","latLngToLayerPoint","p1","p2","LineUtil","pointToSegmentDistance","closestOnSegment","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","closestPointOnSegment","unproject","closestOnCircle","circle","latLng","center","getLatLng","circleRadius","getRadius","radius","x","lng","y","lat","cx","cy","dx","dy","distance","Math","sqrt","tx","ty","LatLng","layer","vertices","i","n","subResult","mindist","result","Array","length","Polyline","JSON","parse","stringify","getLatLngs","slice","Polygon","addLastSegment","latlngsArr","push","ll","this","closestLayer","layers","LayerGroup","getLayers","Circle","closestLayerSnap","tolerance","withVertices","closestResult","Map","mergeOptions","almostOver","almostDistance","almostSamplingPeriod","almostOnMouseMove","AlmostOverHandler","Handler","initialize","_map","_layers","_previous","_marker","_buffer","_mouseMoveSampler","throttle","_onMouseMove","options","addHooks","on","_onMouseClick","computeBuffer","layerPointToLatLng","distanceTo","whenReady","removeHooks","off","addLayer","eachLayer","l","removeLayer","index","indexOf","splice","getClosest","snaplist","e","stamp","fire","type","addInitHook"],"mappings":"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"}